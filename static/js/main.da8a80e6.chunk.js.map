{"version":3,"sources":["maze.ts","renderManager.ts","index.js"],"names":["MazeArr","rowLegnth","maze","roadRun","backPointList","startPositionIndex","endIndex","directionList","this","createEmptyMaze","init","tempMazeRow","totalPushTime","index","push","tempMaze","gapRow","arr","tempMazeOuterFrameRow","createMazeRow","rowIndex","colIndex","YVector","XVector","aroundStaus","checkPositionByVector","times","String","forEach","directionVector","vectorIndex","around","indexOf","arrInclude12","el","value","randomIndex","Math","floor","random","length","index_direction","colChangeTo","status","backIndex_direction","key","sort","a","b","stepNum","row","col","handleNextDirection","checkAround","YV","XV","slice","createEnd","RenderManager","appWidth","rowLength","tileWidth","ballSpeed","ballRadius","ballDiameter","directionData","app","appContainer","keyBoardStatus","endCoordinates","endBounds","mazeGraphics","ballGraphics","keyBoardData","bindHandlePress","bindHandleUnPress","bindGameLoop","Pixi","width","height","backgroundColor","ticker","remove","destroy","children","texture","baseTexture","handleKeyBoardPress","bind","handleKeyBoardUnPress","Maze","mazeIndexMapToCanvasCoordinate","x","y","createBallGraphics","createMazeGraphics","addChild","stage","gameLoop","add","initKeyListener","removeKeyListender","window","confirm","resetConfig","stop","beginFill","drawCircle","endFill","drawRect","endText","fontSize","fill","fontWeight","align","document","addEventListener","removeEventListener","e","leftTopPoint","map","coordinates","tileType","ceil","direction","isWallByXY","isWin","handleWin","isTouchWall","getMaxCoordinates","bodyEl","querySelector","style","margin","padding","innerHeight","innerWidth","renderManager","min","body","appendChild","view"],"mappings":"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","file":"static/js/main.da8a80e6.chunk.js","sourcesContent":["/*\n  array element mean:\n  0:外框, edge\n  1:間隔, interval\n  2:未造訪, Not visited\n  3:已造訪, Visited\n  4:已回朔, Backtracked\n  5:不合法, illegal\n  6:起點, starting point\n  7:終點, end point\n*/\n/*\n  vector array index mean:\n  [up,right,down,left]\n  0:上\n  1:右\n  2:下\n  3:左\n*/\nexport default class MazeArr {\n    maze: string[][]\n    roadRun: string\n    backPointList: any[]\n    startPositionIndex: number\n    endIndex!: {\n        row: number\n        col: number\n    }\n    private rowLegnth: number\n    private directionList: any\n    constructor(rowLegnth?: number) {\n        this.rowLegnth = rowLegnth || 25\n        this.directionList = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n        this.roadRun = ''\n        this.startPositionIndex = (this.rowLegnth - 1) / 2\n        this.backPointList = []\n        this.maze = this.createEmptyMaze()\n        this.init()\n    }\n    createMazeRow() {\n        let tempMazeRow = ['0']  //ex:0,2,1,2,1,2,1,2,0\n        const totalPushTime = (this.rowLegnth - 1) / 2\n        for (let index = 0; index < totalPushTime; index++) {\n            tempMazeRow.push('2')\n            if (index + 1 !== totalPushTime) {\n                tempMazeRow.push('1')\n            }\n        }\n        tempMazeRow.push('0')\n        return tempMazeRow\n    }\n    createEmptyMaze() {\n        let tempMaze = []\n        const gapRow = (() => {\n            let arr = ['0']\n            for (let index = 0; index < this.rowLegnth - 2; index++) {\n                arr.push('1')\n            }\n            arr.push('0')\n            return arr\n        })()\n        const tempMazeOuterFrameRow = (() => {\n            let arr = []\n            for (let index = 0; index < this.rowLegnth; index++) {\n                arr.push('0')\n            }\n            return arr\n        })()\n        tempMaze.push([...tempMazeOuterFrameRow])\n        for (let index = 1; index < this.rowLegnth / 2; index++) {\n            tempMaze.push(this.createMazeRow())\n            if (index !== (this.rowLegnth - 1) / 2) {\n                tempMaze.push([...gapRow])\n            }\n        }\n        tempMaze.push([...tempMazeOuterFrameRow])\n        tempMaze[this.startPositionIndex][this.startPositionIndex] = '6'//設置起點, set start point\n        return [...tempMaze]\n    }\n    checkAround(rowIndex: number, colIndex: number): string[] {\n        let aroundStaus = ['', '', '', ''] //[up,right,bottom,left]\n        let YVector: number\n        let XVector: number\n        const checkPositionByVector = (times: number) => { // 5 is out of boundry\n            if (this.maze[rowIndex + YVector * times]) {\n                if (this.maze[rowIndex + YVector * times][colIndex + XVector * times]) {\n                    return String(this.maze[rowIndex + YVector * times][colIndex + XVector * times])\n                } else {\n                    return '5'\n                }\n            } else {\n                return '5'\n            }\n        }\n        this.directionList.forEach((directionVector: number[], vectorIndex: number) => {\n            YVector = directionVector[0]\n            XVector = directionVector[1]\n            aroundStaus[vectorIndex] = checkPositionByVector(1) + checkPositionByVector(2)\n        });\n        return aroundStaus\n    }\n    handleNextDirection(around: string[]): any {\n        /*\n        有12最優先\n        有36則表示回到起點了\n        若沒有12、36，只有13 33 則往33走 把本身加路徑變為已回朔，注意 終點不改變\n\n        12 is top priority,\n        \n        if 36, meaning have be back to the starting point\n        \n        if without 12、36, and only has 13、33 ,then go 33, \n        making path and self to 4(backtracked).\n        */\n        if (around.indexOf('12') !== -1) {\n            let arrInclude12: { value: string, index: number }[] = []\n            around.forEach((el, index) => {\n                if (el === '12') {\n                    arrInclude12.push({ value: el, index: index })\n                }\n            });\n            let randomIndex = Math.floor(Math.random() * (arrInclude12.length))\n            while (randomIndex === arrInclude12.length) {\n                randomIndex = Math.floor(Math.random() * (arrInclude12.length))\n            }\n            return { index_direction: arrInclude12[randomIndex]['index'], colChangeTo: '3', status: 'roading' }\n        } else {\n            let backIndex_direction\n            if (around.indexOf('36') !== -1) {//回到起點, back to start point\n                for (const key in around) {\n                    if (around[key] === '36') {\n                        backIndex_direction = key\n                    }\n                }\n                //console.log('渲染結束'), render end\n                return { index_direction: backIndex_direction, colChangeTo: '4', status: 'backToStart' }\n            }\n            else if (around.indexOf('44') === -1 && around.indexOf('33') !== -1) {//折返起點, backtracked start point\n                for (const key in around) {\n                    if (around[key] === '33') {\n                        backIndex_direction = key\n                    }\n                }\n                //console.log('折返起點')\n                return { index_direction: backIndex_direction, colChangeTo: '4', status: 'backPoint' }\n            }\n            else if (around.indexOf('33') !== -1) {//折返中, backtracking\n                for (const key in around) {\n                    if (around[key] === '33') {\n                        backIndex_direction = key\n                    }\n                }\n                //console.log('需折返'), need to backtrack\n                return { index_direction: backIndex_direction, colChangeTo: '4', status: 'backing' }\n            }\n        }\n    }\n    createEnd() {\n        this.backPointList.sort(function (a, b) {\n            return b.stepNum - a.stepNum;\n        });\n        this.endIndex = {\n            row: this.backPointList[0].rowIndex,\n            col: this.backPointList[0].colIndex\n        }\n        this.maze[this.backPointList[0].rowIndex][this.backPointList[0].colIndex] = '7'\n    }\n    init() {\n        let rowIndex = this.startPositionIndex\n        let colIndex = this.startPositionIndex\n        while (true) {\n            const { index_direction, colChangeTo, status } = this.handleNextDirection(this.checkAround(rowIndex, colIndex))\n            const YV = this.directionList[index_direction][0]\n            const XV = this.directionList[index_direction][1]\n            if (this.maze[rowIndex][colIndex] !== '6') {\n                this.maze[rowIndex][colIndex] = colChangeTo\n            }\n            this.maze[rowIndex + YV][colIndex + XV] = colChangeTo\n            if (status === 'backToStart') {\n                this.roadRun += index_direction\n                break\n            } else if (status === 'roading') {\n                this.roadRun += index_direction\n            } else if (status === 'backPoint') {\n                this.roadRun = this.roadRun.slice(0, -1);\n                this.backPointList.push({ rowIndex: rowIndex, colIndex: colIndex, stepNum: this.roadRun.length })\n            } else if (status === 'backing') {\n                this.roadRun = this.roadRun.slice(0, -1);\n            }\n            rowIndex = rowIndex + YV * 2\n            colIndex = colIndex + XV * 2\n        }\n        this.createEnd()\n    }\n}","\nimport * as Pixi from 'pixi.js'\nimport Maze from './maze'\nexport default class RenderManager {\n    appWidth: number\n    rowLength: number\n    tileWidth: number //px\n    ballSpeed: number\n    ballRadius: number\n    ballDiameter: number\n    directionData: any\n    //set in init\n    app!: Pixi.Application\n    maze!: Maze\n    appContainer!: Pixi.Container\n    keyBoardStatus!: { 'w': boolean, 'a': boolean, 's': boolean, 'd': boolean }\n    endCoordinates!: number[][]\n    endBounds!: any\n    mazeGraphics!: Pixi.Graphics\n    ballGraphics!: Pixi.Graphics\n    keyBoardData!: any\n    bindHandlePress!: (e: KeyboardEvent) => void\n    bindHandleUnPress!: (e: KeyboardEvent) => void\n    bindGameLoop!: () => void\n    constructor(\n        appWidth: number,\n        rowLength: number\n    ) {\n        this.rowLength = rowLength\n        this.appWidth = appWidth\n        this.tileWidth = appWidth / rowLength\n        this.ballSpeed = this.tileWidth / 3 //ball would go out of tile when too fast\n        this.ballRadius = this.tileWidth / 4\n        this.ballDiameter = this.ballRadius * 2\n        this.app = new Pixi.Application({\n            width: this.appWidth,\n            height: this.appWidth,\n            backgroundColor: 0xFFFFFF\n        })\n        this.init()\n    }\n    resetConfig() {\n        this.app.ticker.remove(this.bindGameLoop)\n        this.appContainer.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        })\n    }\n    init() {\n        this.appContainer = new Pixi.Container()\n        this.bindHandlePress = this.handleKeyBoardPress.bind(this)\n        this.bindHandleUnPress = this.handleKeyBoardUnPress.bind(this)\n        this.maze = new Maze(this.rowLength)\n        this.keyBoardStatus = {\n            'w': false,\n            'a': false,\n            's': false,\n            'd': false\n        }\n        this.endCoordinates = this.mazeIndexMapToCanvasCoordinate(this.maze.endIndex.row, this.maze.endIndex.col)\n        this.endBounds = {\n            x: this.endCoordinates[0][0],\n            y: this.endCoordinates[0][1],\n            width: this.tileWidth,\n            height: this.tileWidth\n        }\n        this.ballGraphics = this.createBallGraphics()\n        this.mazeGraphics = this.createMazeGraphics()\n        this.appContainer.addChild(this.mazeGraphics, this.ballGraphics)\n        this.ballGraphics.x = (this.appWidth / 2) - this.ballRadius\n        this.ballGraphics.y = (this.appWidth / 2) - this.ballRadius\n        this.app.stage.addChild(this.appContainer)\n        this.bindGameLoop = this.gameLoop.bind(this)\n        this.app.ticker.add(this.bindGameLoop)\n        this.initKeyListener()\n    }\n    isWin() {\n        return this.ballGraphics.x + this.ballDiameter > this.endBounds.x &&\n            this.ballGraphics.x < this.endBounds.x + this.endBounds.width &&\n            this.ballGraphics.y + this.ballDiameter > this.endBounds.y &&\n            this.ballGraphics.y < this.endBounds.y + this.endBounds.height;\n    }\n    handleWin() {\n        this.removeKeyListender()\n        if (window.confirm('win，another game?')) {\n            this.resetConfig()\n            this.init()\n        } else {\n            this.app.ticker.stop()\n        }\n    }\n    createBallGraphics() {\n        let ballGraphics = new Pixi.Graphics()\n        ballGraphics.beginFill(0xff0000);\n        ballGraphics.drawCircle(this.ballRadius, this.ballRadius, this.ballRadius)\n        ballGraphics.endFill();\n        return ballGraphics\n    }\n    createMazeGraphics() {\n        let mazeGraphics = new Pixi.Graphics()\n        this.maze.maze.forEach((row, rowIndex) => {\n            row.forEach((col, colIndex) => {\n                if (col === '1' || col === '0') { // 1 is wall, 0 is edge\n                    mazeGraphics.beginFill(0x000000);\n                    mazeGraphics.drawRect(\n                        this.tileWidth * rowIndex,\n                        this.tileWidth * colIndex,\n                        this.tileWidth,\n                        this.tileWidth)\n                    mazeGraphics.endFill();\n                }\n                else if (col === '7') { //end\n                    const endText = new Pixi.Text('終', { fontSize: this.tileWidth, fill: 0xff0000, fontWeight: 900, align: \"\" });\n                    mazeGraphics.addChild(endText)\n                    endText.x = rowIndex * this.tileWidth + (this.tileWidth - endText.width) / 2\n                    endText.y = colIndex * this.tileWidth + (this.tileWidth - endText.width) / 2\n                }\n            })\n        })\n        return mazeGraphics\n    }\n    initKeyListener() {\n        document.addEventListener('keyup', this.bindHandleUnPress)\n        document.addEventListener('keydown', this.bindHandlePress)\n    }\n    removeKeyListender() {\n        document.removeEventListener('keyup', this.bindHandleUnPress)\n        document.removeEventListener('keydown', this.bindHandlePress)\n    }\n    handleKeyBoardPress(e: KeyboardEvent) {\n        const { key } = e\n        if (!(key in this.keyBoardStatus)) {\n            return\n        }\n        //@ts-ignore\n        this.keyBoardStatus[key] = true\n    }\n    handleKeyBoardUnPress(e: KeyboardEvent) {\n        const { key } = e\n        if (!(key in this.keyBoardStatus)) {\n            return\n        }\n        //@ts-ignore\n        this.keyBoardStatus[key] = false\n    }\n    mazeIndexMapToCanvasCoordinate(rowIndex: number, colIndex: number) {\n        const leftTopPoint = [rowIndex * this.tileWidth, colIndex * this.tileWidth]\n        return [leftTopPoint, leftTopPoint.map(coordinates => coordinates + this.tileWidth)]\n    }\n    isWallByXY(x: number, y: number) {\n        const tileType = this.maze.maze[Math.ceil(x / this.tileWidth) - 1][Math.ceil(y / this.tileWidth) - 1]\n        return tileType === '0' || tileType === '1' //0 is edge, 1 is wall\n    }\n    getMaxCoordinates(direction: 'up' | 'down' | 'left' | 'right', x: number, y: number) {//when touch wall\n        switch (direction) {\n            case 'up':\n                return y - y % this.tileWidth + 2\n            case 'right':\n                return x - (x + this.ballDiameter) % this.tileWidth + this.tileWidth - 2\n            case 'down':\n                return y - (y + this.ballDiameter) % this.tileWidth + this.tileWidth - 2\n            case 'left':\n                return x - x % this.tileWidth + 2\n        }\n    }\n    isTouchWall(direction: 'up' | 'down' | 'left' | 'right', x: number, y: number) {\n        switch (direction) {\n            case 'up':\n                if (this.isWallByXY(x, y - this.ballSpeed) ||\n                    this.isWallByXY(x + this.ballDiameter, y - this.ballSpeed)) {\n                    return true\n                }\n                break\n            case 'right':\n                if (this.isWallByXY(x + this.ballDiameter + this.ballSpeed, y) ||\n                    this.isWallByXY(x + this.ballDiameter + this.ballSpeed, y + this.ballDiameter)) {\n                    return true\n                }\n                break\n            case 'down':\n                if (this.isWallByXY(x, y + this.ballDiameter + this.ballSpeed) ||\n                    this.isWallByXY(x + this.ballDiameter, y + this.ballDiameter + this.ballSpeed)) {\n                    return true\n                }\n                break\n            case 'left':\n                if (this.isWallByXY(x - this.ballSpeed, y) ||\n                    this.isWallByXY(x - this.ballSpeed, y + this.ballDiameter)) {\n                    return true\n                }\n                break\n        }\n        return false\n    }\n    gameLoop() {\n        if (this.keyBoardStatus['w']) {\n            if (this.isWin()) {\n                this.handleWin()\n                return\n            }\n            const { x, y } = this.ballGraphics\n            if (this.isTouchWall('up', x, y)) {\n                this.ballGraphics.y = this.getMaxCoordinates('up', x, y)\n            } else {\n                this.ballGraphics.y -= this.ballSpeed\n            }\n        }\n        if (this.keyBoardStatus['a']) {\n            if (this.isWin()) {\n                this.handleWin()\n                return\n            }\n            const { x, y } = this.ballGraphics\n            if (this.isTouchWall('left', x, y)) {\n                this.ballGraphics.x = this.getMaxCoordinates('left', x, y)\n            } else {\n                this.ballGraphics.x -= this.ballSpeed\n            }\n        }\n        if (this.keyBoardStatus['s']) {\n            if (this.isWin()) {\n                this.handleWin()\n                return\n            }\n            const { x, y } = this.ballGraphics\n            if (this.isTouchWall('down', x, y)) {\n                this.ballGraphics.y = this.getMaxCoordinates('down', x, y)\n            } else {\n                this.ballGraphics.y += this.ballSpeed\n            }\n        }\n        if (this.keyBoardStatus['d']) {\n            if (this.isWin()) {\n                this.handleWin()\n                return\n            }\n            const { x, y } = this.ballGraphics\n            if (this.isTouchWall('right', x, y)) {\n                this.ballGraphics.x = this.getMaxCoordinates('right', x, y)\n            } else {\n                this.ballGraphics.x += this.ballSpeed\n            }\n        }\n    }\n}","import RenderManager from './renderManager'\nconst bodyEl = document.querySelector('body')\nbodyEl.style.margin = 0\nbodyEl.style.padding = 0\nconst { innerHeight, innerWidth } = window\nconst TILE_NUM = 19 // it must match 7+4n \nconst renderManager = new RenderManager(Math.min(innerHeight, innerWidth), TILE_NUM)\ndocument.body.appendChild(renderManager.app.view)"],"sourceRoot":""}