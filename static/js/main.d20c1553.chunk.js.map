{"version":3,"sources":["maze.ts","Ball.ts","renderManager.ts","index.js"],"names":["MazeArr","rowLegnth","maze","roadRun","backPointList","startPositionIndex","endIndex","directionList","this","init","tempMazeRow","totalPushTime","index","push","tempMaze","gapRow","arr","tempMazeOuterFrameRow","createMazeRow","rowIndex","colIndex","YVector","XVector","aroundStaus","checkPositionByVector","times","String","forEach","directionVector","vectorIndex","around","indexOf","arrInclude12","el","value","randomIndex","Math","floor","random","length","index_direction","colChangeTo","status","backIndex_direction","key","sort","a","b","stepNum","row","col","createEmptyMaze","handleNextDirection","checkAround","YV","XV","slice","createEnd","Ball","tileWidth","speed","radius","diameter","graphics","createBallGraphics","ballGraphics","Pixi","beginFill","drawCircle","endFill","bounds","x","width","y","height","RenderManager","appWidth","rowLength","directionData","itemData","ball","app","appContainer","keyBoardStatus","endCoordinates","endBounds","mazeGraphics","bindHandlePress","bindHandleUnPress","bindGameLoop","backgroundColor","w","direction","axis","vector","s","d","1","name","whenTouch","7","removeKeyListender","window","confirm","resetConfig","ticker","stop","remove","destroy","children","texture","baseTexture","handleKeyBoardPress","bind","handleKeyBoardUnPress","Maze","mazeIndexMapToCanvasCoordinate","createMazeGraphics","addChild","stage","gameLoop","add","initKeyListener","drawRect","endText","fontSize","fill","fontWeight","align","document","addEventListener","removeEventListener","e","leftTopPoint","map","coordinates","tileType","ceil","isWallByXY","keyCode","isTouchByBounds","handleWin","isTouchWall","getMaxCoordinates","handleKeyBoardStatus","bodyEl","querySelector","style","margin","padding","innerHeight","innerWidth","renderManager","min","body","appendChild","view"],"mappings":"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","file":"static/js/main.d20c1553.chunk.js","sourcesContent":["/*\n  array element mean:\n  0:外框, edge\n  1:間隔, interval\n  2:未造訪, Not visited\n  3:已造訪, Visited\n  4:已回朔, Backtracked\n  5:不合法, illegal\n  6:起點, starting point\n  7:終點, end point\n*/\n/*\n  vector array index mean:\n  [up,right,down,left]\n  0:上\n  1:右\n  2:下\n  3:左\n*/\nexport default class MazeArr {\n    maze!: string[][]\n    roadRun: string\n    backPointList: any[]\n    startPositionIndex: number\n    endIndex!: {\n        row: number\n        col: number\n    }\n    private rowLegnth: number\n    private directionList: any\n    constructor(rowLegnth?: number) {\n        this.rowLegnth = rowLegnth || 25\n        this.directionList = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n        this.roadRun = ''\n        this.startPositionIndex = (this.rowLegnth - 1) / 2\n        this.backPointList = []\n        this.init()\n    }\n    createMazeRow() {\n        let tempMazeRow = ['0']  //ex:0,2,1,2,1,2,1,2,0\n        const totalPushTime = (this.rowLegnth - 1) / 2\n        for (let index = 0; index < totalPushTime; index++) {\n            tempMazeRow.push('2')\n            if (index + 1 !== totalPushTime) {\n                tempMazeRow.push('1')\n            }\n        }\n        tempMazeRow.push('0')\n        return tempMazeRow\n    }\n    createEmptyMaze() {\n        let tempMaze = []\n        const gapRow = (() => {\n            let arr = ['0']\n            for (let index = 0; index < this.rowLegnth - 2; index++) {\n                arr.push('1')\n            }\n            arr.push('0')\n            return arr\n        })()\n        const tempMazeOuterFrameRow = (() => {\n            let arr = []\n            for (let index = 0; index < this.rowLegnth; index++) {\n                arr.push('0')\n            }\n            return arr\n        })()\n        tempMaze.push([...tempMazeOuterFrameRow])\n        for (let index = 1; index < this.rowLegnth / 2; index++) {\n            tempMaze.push(this.createMazeRow())\n            if (index !== (this.rowLegnth - 1) / 2) {\n                tempMaze.push([...gapRow])\n            }\n        }\n        tempMaze.push([...tempMazeOuterFrameRow])\n        tempMaze[this.startPositionIndex][this.startPositionIndex] = '6'//設置起點, set start point\n        return [...tempMaze]\n    }\n    checkAround(rowIndex: number, colIndex: number): string[] {\n        let aroundStaus = ['', '', '', ''] //[up,right,bottom,left]\n        let YVector: number\n        let XVector: number\n        const checkPositionByVector = (times: number) => { // 5 is out of boundry\n            if (this.maze[rowIndex + YVector * times]) {\n                if (this.maze[rowIndex + YVector * times][colIndex + XVector * times]) {\n                    return String(this.maze[rowIndex + YVector * times][colIndex + XVector * times])\n                } else {\n                    return '5'\n                }\n            } else {\n                return '5'\n            }\n        }\n        this.directionList.forEach((directionVector: number[], vectorIndex: number) => {\n            YVector = directionVector[0]\n            XVector = directionVector[1]\n            aroundStaus[vectorIndex] = checkPositionByVector(1) + checkPositionByVector(2)\n        });\n        return aroundStaus\n    }\n    \n    handleNextDirection(around: string[]): any {\n        /*\n        有12最優先\n        有36則表示回到起點了\n        若沒有12、36，只有13 33 則往33走 把本身加路徑變為已回朔，注意 終點不改變\n\n        12 is top priority,\n        \n        if 36, meaning have be back to the starting point\n        \n        if without 12、36, and only has 13、33 ,then go 33, \n        making path and self to 4(backtracked).\n        */\n        if (around.indexOf('12') !== -1) {\n            let arrInclude12: { value: string, index: number }[] = []\n            around.forEach((el, index) => {\n                if (el === '12') {\n                    arrInclude12.push({ value: el, index: index })\n                }\n            });\n            let randomIndex = Math.floor(Math.random() * (arrInclude12.length))\n            while (randomIndex === arrInclude12.length) {\n                randomIndex = Math.floor(Math.random() * (arrInclude12.length))\n            }\n            return { index_direction: arrInclude12[randomIndex]['index'], colChangeTo: '3', status: 'roading' }\n        } else {\n            let backIndex_direction\n            if (around.indexOf('36') !== -1) {//回到起點, back to start point\n                for (const key in around) {\n                    if (around[key] === '36') {\n                        backIndex_direction = key\n                    }\n                }\n                //console.log('渲染結束'), render end\n                return { index_direction: backIndex_direction, colChangeTo: '4', status: 'backToStart' }\n            }\n            else if (around.indexOf('44') === -1 && around.indexOf('33') !== -1) {//折返起點, backtracked start point\n                for (const key in around) {\n                    if (around[key] === '33') {\n                        backIndex_direction = key\n                    }\n                }\n                //console.log('折返起點')\n                return { index_direction: backIndex_direction, colChangeTo: '4', status: 'backPoint' }\n            }\n            else if (around.indexOf('33') !== -1) {//折返中, backtracking\n                for (const key in around) {\n                    if (around[key] === '33') {\n                        backIndex_direction = key\n                    }\n                }\n                //console.log('需折返'), need to backtrack\n                return { index_direction: backIndex_direction, colChangeTo: '4', status: 'backing' }\n            }\n        }\n    }\n    createEnd() {\n        this.backPointList.sort(function (a, b) {\n            return b.stepNum - a.stepNum;\n        });\n        this.endIndex = {\n            row: this.backPointList[0].rowIndex,\n            col: this.backPointList[0].colIndex\n        }\n        this.maze[this.backPointList[0].rowIndex][this.backPointList[0].colIndex] = '7'\n    }\n    init() {\n        this.maze = this.createEmptyMaze()\n        let rowIndex = this.startPositionIndex\n        let colIndex = this.startPositionIndex\n        while (true) {\n            const { index_direction, colChangeTo, status } = this.handleNextDirection(this.checkAround(rowIndex, colIndex))\n            const YV = this.directionList[index_direction][0]\n            const XV = this.directionList[index_direction][1]\n            if (this.maze[rowIndex][colIndex] !== '6') {\n                this.maze[rowIndex][colIndex] = colChangeTo\n            }\n            this.maze[rowIndex + YV][colIndex + XV] = colChangeTo\n            if (status === 'backToStart') {\n                this.roadRun += index_direction\n                break\n            } else if (status === 'roading') {\n                this.roadRun += index_direction\n            } else if (status === 'backPoint') {\n                this.roadRun = this.roadRun.slice(0, -1);\n                this.backPointList.push({ rowIndex: rowIndex, colIndex: colIndex, stepNum: this.roadRun.length })\n            } else if (status === 'backing') {\n                this.roadRun = this.roadRun.slice(0, -1);\n            }\n            rowIndex = rowIndex + YV * 2\n            colIndex = colIndex + XV * 2\n        }\n        this.createEnd()\n    }\n}","import * as Pixi from 'pixi.js'\r\nexport default class Ball {\r\n    tileWidth: number\r\n    speed: number\r\n    radius: number\r\n    diameter: number\r\n    graphics: Pixi.Graphics\r\n    constructor(tileWidth: number) {\r\n        this.tileWidth = tileWidth\r\n        this.speed = tileWidth / 3 //ball would go out of tile when too fast\r\n        this.radius = tileWidth / 4\r\n        this.diameter = this.radius * 2\r\n        this.graphics = this.createBallGraphics()\r\n    }\r\n    createBallGraphics() {\r\n        let ballGraphics = new Pixi.Graphics()\r\n        ballGraphics.beginFill(0xff0000);\r\n        ballGraphics.drawCircle(this.radius, this.radius, this.radius)\r\n        ballGraphics.endFill();\r\n        return ballGraphics\r\n    }\r\n    isTouchByBounds(bounds: { x: number, y: number, width: number, height: number }) {\r\n        return this.graphics.x + this.diameter > bounds.x &&\r\n            this.graphics.x < bounds.x + bounds.width &&\r\n            this.graphics.y + this.diameter > bounds.y &&\r\n            this.graphics.y < bounds.y + bounds.height;\r\n    }\r\n}","\nimport * as Pixi from 'pixi.js'\nimport Maze from './maze'\nimport Ball from './Ball'\nexport default class RenderManager {\n    appWidth: number\n    rowLength: number\n    tileWidth: number //px\n    directionData: {\n        [key: string]: {\n            axis: 'y' | 'x',\n            vector: -1 | 1,\n            direction: 'up' | 'left' | 'down' | 'right'\n        }\n    }\n    itemData: any\n    //set in init\n    ball!: Ball\n    app!: Pixi.Application\n    maze!: Maze\n    appContainer!: Pixi.Container\n    keyBoardStatus!: { 'w': boolean, 'a': boolean, 's': boolean, 'd': boolean }\n    endCoordinates!: number[][]\n    endBounds!: any\n    mazeGraphics!: Pixi.Graphics\n    bindHandlePress!: (e: KeyboardEvent) => void\n    bindHandleUnPress!: (e: KeyboardEvent) => void\n    bindGameLoop!: () => void\n    constructor(\n        appWidth: number,\n        rowLength: number\n    ) {\n        this.rowLength = rowLength\n        this.appWidth = appWidth\n        this.tileWidth = appWidth / rowLength\n        this.app = new Pixi.Application({\n            width: this.appWidth,\n            height: this.appWidth,\n            backgroundColor: 0xFFFFFF\n        })\n        this.directionData = {\n            w: {\n                direction: 'up',\n                axis: 'y',\n                vector: -1\n            },\n            a: {\n                direction: 'left',\n                axis: 'x',\n                vector: -1\n            },\n            s: {\n                direction: 'down',\n                axis: 'y',\n                vector: 1\n            },\n            d: {\n                direction: 'right',\n                axis: 'x',\n                vector: 1\n            },\n        }\n        this.itemData = {\n            1: {\n                name: 'wall',\n                whenTouch: () => {\n\n                }\n            },\n            7: {\n                name: 'endPoint',\n                whenTouch: () => {\n                    this.removeKeyListender()\n                    if (window.confirm('win，another game?')) {\n                        this.resetConfig()\n                        this.init()\n                    } else {\n                        this.app.ticker.stop()\n                    }\n                }\n            }\n        }\n        this.init()\n    }\n    resetConfig() {\n        this.app.ticker.remove(this.bindGameLoop)\n        this.appContainer.destroy({\n            children: true,\n            texture: true,\n            baseTexture: true\n        })\n    }\n    init() {\n        this.appContainer = new Pixi.Container()\n        this.bindHandlePress = this.handleKeyBoardPress.bind(this)\n        this.bindHandleUnPress = this.handleKeyBoardUnPress.bind(this)\n        this.maze = new Maze(this.rowLength)\n        this.keyBoardStatus = {\n            'w': false,\n            'a': false,\n            's': false,\n            'd': false\n        }\n        this.endCoordinates = this.mazeIndexMapToCanvasCoordinate(this.maze.endIndex.row, this.maze.endIndex.col)\n        this.endBounds = {\n            x: this.endCoordinates[0][0],\n            y: this.endCoordinates[0][1],\n            width: this.tileWidth,\n            height: this.tileWidth\n        }\n        this.mazeGraphics = this.createMazeGraphics()\n        this.ball = new Ball(this.tileWidth)\n        this.appContainer.addChild(this.mazeGraphics, this.ball.graphics)\n        this.ball.graphics.x = (this.appWidth / 2) - this.ball.radius\n        this.ball.graphics.y = (this.appWidth / 2) - this.ball.radius\n        this.app.stage.addChild(this.appContainer)\n        this.bindGameLoop = this.gameLoop.bind(this)\n        this.app.ticker.add(this.bindGameLoop)\n        this.initKeyListener()\n    }\n    handleWin() {\n        this.removeKeyListender()\n        if (window.confirm('win，another game?')) {\n            this.resetConfig()\n            this.init()\n        } else {\n            this.app.ticker.stop()\n        }\n    }\n    createMazeGraphics() {\n        let mazeGraphics = new Pixi.Graphics()\n        this.maze.maze.forEach((row, rowIndex) => {\n            row.forEach((col, colIndex) => {\n                if (col === '1' || col === '0') { // 1 is wall, 0 is edge\n                    mazeGraphics.beginFill(0x000000);\n                    mazeGraphics.drawRect(\n                        this.tileWidth * rowIndex,\n                        this.tileWidth * colIndex,\n                        this.tileWidth,\n                        this.tileWidth)\n                    mazeGraphics.endFill();\n                }\n                else if (col === '7') { //end\n                    const endText = new Pixi.Text('終', { fontSize: this.tileWidth, fill: 0xff0000, fontWeight: 900, align: \"\" });\n                    mazeGraphics.addChild(endText)\n                    endText.x = rowIndex * this.tileWidth + (this.tileWidth - endText.width) / 2\n                    endText.y = colIndex * this.tileWidth + (this.tileWidth - endText.width) / 2\n                }\n            })\n        })\n        return mazeGraphics\n    }\n    initKeyListener() {\n        document.addEventListener('keyup', this.bindHandleUnPress)\n        document.addEventListener('keydown', this.bindHandlePress)\n    }\n    removeKeyListender() {\n        document.removeEventListener('keyup', this.bindHandleUnPress)\n        document.removeEventListener('keydown', this.bindHandlePress)\n    }\n    handleKeyBoardPress(e: KeyboardEvent) {\n        const { key } = e\n        if (!(key in this.keyBoardStatus)) {\n            return\n        }\n        //@ts-ignore\n        this.keyBoardStatus[key] = true\n    }\n    handleKeyBoardUnPress(e: KeyboardEvent) {\n        const { key } = e\n        if (!(key in this.keyBoardStatus)) {\n            return\n        }\n        //@ts-ignore\n        this.keyBoardStatus[key] = false\n    }\n    mazeIndexMapToCanvasCoordinate(rowIndex: number, colIndex: number) {\n        const leftTopPoint = [rowIndex * this.tileWidth, colIndex * this.tileWidth]\n        return [leftTopPoint, leftTopPoint.map(coordinates => coordinates + this.tileWidth)]\n    }\n    isWallByXY(x: number, y: number) {\n        const tileType = this.maze.maze[Math.ceil(x / this.tileWidth) - 1][Math.ceil(y / this.tileWidth) - 1]\n        return tileType === '0' || tileType === '1' //0 is edge, 1 is wall\n    }\n    getMaxCoordinates(direction: 'up' | 'down' | 'left' | 'right', x: number, y: number) {//when touch wall\n        switch (direction) {\n            case 'up':\n                return y - y % this.tileWidth + 2\n            case 'right':\n                return x - (x + this.ball.diameter) % this.tileWidth + this.tileWidth - 2\n            case 'down':\n                return y - (y + this.ball.diameter) % this.tileWidth + this.tileWidth - 2\n            case 'left':\n                return x - x % this.tileWidth + 2\n        }\n    }\n    isTouchWall(direction: 'up' | 'down' | 'left' | 'right', x: number, y: number) {\n        switch (direction) {\n            case 'up':\n                if (this.isWallByXY(x, y - this.ball.speed) ||\n                    this.isWallByXY(x + this.ball.diameter, y - this.ball.speed)) {\n                    return true\n                }\n                break\n            case 'right':\n                if (this.isWallByXY(x + this.ball.diameter + this.ball.speed, y) ||\n                    this.isWallByXY(x + this.ball.diameter + this.ball.speed, y + this.ball.diameter)) {\n                    return true\n                }\n                break\n            case 'down':\n                if (this.isWallByXY(x, y + this.ball.diameter + this.ball.speed) ||\n                    this.isWallByXY(x + this.ball.diameter, y + this.ball.diameter + this.ball.speed)) {\n                    return true\n                }\n                break\n            case 'left':\n                if (this.isWallByXY(x - this.ball.speed, y) ||\n                    this.isWallByXY(x - this.ball.speed, y + this.ball.diameter)) {\n                    return true\n                }\n                break\n        }\n        return false\n    }\n    handleKeyBoardStatus(keyCode: 'w' | 'a' | 's' | 'd') {\n        if (this.ball.isTouchByBounds(this.endBounds)) {\n            this.handleWin()\n            return\n        }\n        const { x, y } = this.ball.graphics\n        const { vector, direction, axis } = this.directionData[keyCode]\n        if (this.isTouchWall(direction, x, y)) {\n            this.ball.graphics[axis] = this.getMaxCoordinates(direction, x, y)\n        } else {\n            this.ball.graphics[axis] += this.ball.speed * vector\n        }\n\n    }\n    gameLoop() {\n        if (!this.keyBoardStatus['w'] || !this.keyBoardStatus['s']) {\n            if (this.keyBoardStatus['w']) {\n                this.handleKeyBoardStatus('w')\n            }\n            if (this.keyBoardStatus['s']) {\n                this.handleKeyBoardStatus('s')\n            }\n        }\n        if (!this.keyBoardStatus['a'] || !this.keyBoardStatus['d']) {\n            if (this.keyBoardStatus['a']) {\n                this.handleKeyBoardStatus('a')\n            }\n            if (this.keyBoardStatus['d']) {\n                this.handleKeyBoardStatus('d')\n            }\n        }\n    }\n}","import RenderManager from './renderManager'\nconst bodyEl = document.querySelector('body')\nbodyEl.style.margin = 0\nbodyEl.style.padding = 0\nconst { innerHeight, innerWidth } = window\nconst TILE_NUM = 19 // it must match 7+4n \nconst renderManager = new RenderManager(Math.min(innerHeight, innerWidth), TILE_NUM)\ndocument.body.appendChild(renderManager.app.view)"],"sourceRoot":""}